<html>
<head>
  <meta charset="utf-8">

  <script src="./js/vue.js"></script>
  <script src="./js/superflatten.js"></script>
  <style>

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}

  body{
    font-family: "Helvetica Neue", -apple-system,BlinkMacSystemFont,Segoe UI,Hiragino Kaku Gothic ProN,"メイリオ",meiryo,sans-serif;
    /*font-family: "Helvetica Neue", Helvetica, Arial, "游ゴシック体", "Yu Gothic", YuGothic, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif*/
  }
  .header {
    height: 40px;
    background-color: #12486A;
    color: white;
    text-align: center;
  }
  .content{
    height: calc(100% - 40px);
  }
  .column {
    display: block;
    width: 50%;
    float: left;
    height: 100%;
  }
  .row {
    width: 100%;
  }
  textarea.json {
    width: 100%;
    height: 100%;
  }
  pre.json {
    width: calc(100% - 1em);
    height: calc(100% - 1em);
    overflow: scroll;
    padding: 1em 0 0 1em;
    color: #000;
    background-color: #f6f6f6;
    font-family: 'MS Gothic', monospace;
  }
  .btn {
    display: inline-block;
    background-color: #0275d8;
    color: white;
    padding: 10px 25px;
    border-radius: 20px;
    text-align: center;
  }
  .datatable {
	  border-collapse: collapse;
    font-size: 0.8em;
  }
  .datatable th,.datatable td {
  	border: 1px solid rgb(221, 221, 221);
    padding: 5px 10px;
    vertical-align: middle;
    word-break: keep-all;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
  }
  .datatable tr:nth-child(even) {
  	background: #f9f9f9;
  }
  .datatable tr:hover {
  	background: #ff0;
  }
  .paginate {
    letter-spacing: -.4em;
  }
  .paginate li:first-child {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .paginate li:last-child {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
  .paginate > li{
    display: inline-block;
    letter-spacing: normal;
  }
  .paginate_button {
    padding: 8px 12px;
    border: 1px solid rgb(221, 221, 221);
    margin: 0px;
  }
  .paginate_button.active {
    background-color: rgb(221, 221, 221);
  }
  .vertical:hover {
    cursor: n-resize;
  }
  .horizontal:hover {
    cursor: e-resize;
  }

  .status_button {
    width: 66px;
    margin: 0;
    padding: 1px 0;
    text-align: center;
    user-select: none;
    border: 0;
    font-size: 10px;
    background-color: slategray;
    color: white;
    border-radius: 3px;
  }
  .status_button.active {
    background-color: #01478D;
    color: white;
  }
  </style>
</head>
<body>
  <header class="header"><h2 style="font-size: 2em;">JSON to CSV</h2></header>
  <div id="app" class="content">
    <div style="height: 100% position: relative;">
      <x-row :h="'50% - ' + middleSeparatorOffset.y + 'px'">
        <x-json :csvdata="csvdata" :w="leftPanelWidth" ></x-json>
        <x-separator :offset="upperMiddleSeparatorOffset" direction="horizontal" :h="'50% - 18px - ' + middleSeparatorOffset.y + 'px'" w="5px" top="40px" left="70%"></x-separator>
        <x-config :schema="schema.root" :count="schema.count" :w="rightPanelWidth" h="100%" ></x-config>
      </x-row>
      <x-row :h="'50% + ' + middleSeparatorOffset.y + 'px'">
        <x-separator :offset="middleSeparatorOffset" direction="vertical" h="5px" w="100%" top="50% + 20px" left="0px"></x-separator>
        <x-csv :csvdata="csvdata"></x-csv>
      </x-row>
    </div>
  </div>


<script>

function FlattenContext() {
  this.names = [];
  this.schema = null;
  this.flattenedSchema = {};
}
FlattenContext.prototype.getNames = function() {
  return this.names;
}
FlattenContext.prototype.setSchema = function(schema) {
  this.schema = schema;
  this.flattenedSchema = this.flattenSchema(schema, new FlattenContext());
  // console.log(this.flattenedSchema);
}
FlattenContext.prototype.flattenSchema = function(schema, context) {
  var ret = {};
  ret[context.currentName()] = schema;
  for (var key in schema.children) {
    var child = schema.children[key];
    context.push(key);
    Object.assign(ret, this.flattenSchema(child, context));
    context.pop();
  }
  return ret;
}
FlattenContext.prototype.push = function(name) {
  this.names.push(name);
}
FlattenContext.prototype.pop = function() {
  this.names.splice(this.names.length - 1, 1);
}
FlattenContext.prototype.currentName = function() {
  var ret = "";
  for (var i = 0; i < this.names.length; i++) {
    var name = this.names[i];
    if (ret.length > 0) {
      ret += ".";
    }
    ret += name;
  }
  return ret;
}
FlattenContext.prototype.getExtractStatus = function(key) {
  if (!key) {
    key = '';
  }
  var name = this.currentName();
  if (name.length === 0) {
    name = key;
  } else {
    name += (key.length > 0 ? '.' : '') + key;
  }
  return this.flattenedSchema[name].status;
}

function flatten(obj, context) {
  if (!context) {
    context = new FlattenContext();
  }
  if (Array.isArray(obj) ) {
    const ret = [];
    obj.forEach(elem => {
      ret.push(flatten(elem, context));
    });
    return ret;
  } else if (typeof obj === 'object') {
    var ret = {};
    for (key in obj) {
      const value = obj[key];
      context.push(key);
      Object.assign(ret, flatten(value, context));
      context.pop();
    }
    return ret;
  } else {
    const ret = {};
    ret[context.currentName()] = obj;
    return ret;
  }
}

function extract(obj, name) {
  const ret = [];
  const list = obj[name];
  for (var i = 0; i < list.length; i++) {
    const elem = list[i];
    const retObj = Object.assign({}, obj);
    delete retObj[name];
    ret.push(retObj);
    var thisName = name + "";
    if (typeof elem === 'object') {
      if (Array.isArray(elem)) {
        retObj[thisName + ".[]"] = elem;
      } else {
        for (key in elem) {
          retObj[thisName + "." + key] = elem[key];
        }
      }
    } else {
      retObj[thisName] =  elem;
    }
  }
  return ret;
}

function getArrayNameList(obj) {
  const ret = [];
  for (key in obj) {
    if (Array.isArray(obj[key])) {
      ret.push(key);
    }
  }
  return ret;
}

function hasArray(obj) {
  for(var key in obj) {
    var elem = obj[key];
    if (Array.isArray(elem)) {
      return true;
    } else if (typeof elem === 'object') {
      var ret = hasArray(elem);
      if (ret) {
        return true;
      }
    } else {
      // no operation
    }
  }
  return false;
}

function extractAll(list, context) {
  if (!context) {
    context = new FlattenContext();
  }
  const extractStatus = context.getExtractStatus();
  if (extractStatus === 'OFF') {
    return [];
  }
  // console.log(context.currentName() + ":" + extractStatus);
  var extractedList = [];
  var noExtractList = [];
  var extracted = false;
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    var thisObjExtracted = false;
    if (Array.isArray(obj)) {
      // if "obj" is list, then flatten it.
      // [[1, 2], [3], [4, 5], ...] -> [1, 2, 3, 4, 5, ]
      if (extractStatus === 'FLATTEN') {
        // console.log("test");
        var tmp = {};
        for (var j = 0; j < obj.length; j++) {
          tmp[j] = obj[j];
        }
        const childList = [tmp];
        while(extractAll(childList, context)) {};
        Array.prototype.push.apply(extractedList, childList);
      } else {
        Array.prototype.push.apply(extractedList, obj);
        extracted = true;
        thisObjExtracted = true;
      }
    } else if (typeof obj === 'object') {
      // if "obj" is object, then loop for all the elements in the object
      for (var key in obj) {
        // console.log(key);
        const childExtractStatus = context.getExtractStatus(key);
        if (childExtractStatus === 'OFF') {
          delete obj[key];
        }
        var elem  = obj[key];
        // if (childExtractStatus === 'FLATTEN') {
        //   elem = {};
        //   for (var i = 0; i < obj[key].length; i++) {
        //     var tmp = obj[key][i];
        //     elem[i] = tmp;
        //   }
        //   obj[key] = elem;
        // }
        if (Array.isArray(elem)) {
          // if elem is list, then extract the list
          // console.log(childExtractStatus);
          if (elem.length > 0) {
            Array.prototype.push.apply(extractedList, extract(obj, key));
            extracted = true;
            thisObjExtracted = true;
            break;
          } else {
            delete obj[key];
          }
        } else if (typeof elem === 'object') {
          if (hasArray(elem)) {
            // if the "elem" contains list, then extract
            var extractedCount = 0;
            const childList = [elem];
            context.push(key);
            while(extractAll(childList, context)) {extractedCount++;};
            context.pop();
            if (extractedCount > 0) {
              obj[key] = childList;
              return true;
            }
          }
          continue;
        } else {
          // list of value not need to be extracted
        }
      }
    } else {
      // list of value not need to be extracted
    }
    if (!thisObjExtracted) {
      noExtractList.push(obj);
    }
  }
  if (extracted) {
    list.splice(0, list.length);
    Array.prototype.push.apply(list, extractedList);
    Array.prototype.push.apply(list, noExtractList);
  }
  return extracted;
}
const Type = {
  object: 'object',
  list: 'list',
  value: 'value',
}
const Schema = function(type, name) {
  this.type = type;
  this.name = name;
  this.parent = null;
  this.children = {};
  this.listSize = 0;

  switch (type) {
    case 'object':
      this.status = 'ON';
      break;
    case 'list':
      this.status = 'EXTRACT';
      break;
    case 'value':
      this.status = 'ON';
      break;
    default:
      break;
  }
}
Schema.prototype.getParent = function() {
  return this.parent;
}
Schema.prototype.setParent = function(parent) {
  this.parent = parent;
}
Schema.prototype.getChild = function(name) {
  return this.children[name];
}
Schema.prototype.addChild = function(schema) {
  if (!this.children[schema.getName()]) {
    this.children[schema.getName()] = schema;
  }
  return this.children[schema.getName()];
}
Schema.prototype.getName = function() {
  return this.name;
}
Schema.prototype.addListSize = function(listSize) {
  this.listSize += listSize;
}

const SchemaContext = function() {
  this.names = ['#root'];
  this.rootSchema = null;
  this.parentSchema = null;
  this.currentSchema = null;
}
// SchemaContext.prototype.registered = function() {
//   return this.currentSchema;
// }
SchemaContext.prototype.currentName = function() {
  return this.names[this.names.length - 1];
}
SchemaContext.prototype.registerSchema = function(type, name, listSize) {
  // console.log(type+ "," + name);
  var schema = new Schema(type, name);
  if (!this.rootSchema) {
    this.rootSchema = schema;
  }
  if (this.parentSchema) {
    schema.setParent(this.parentSchema);
    schema = this.parentSchema.addChild(schema);
  }
  this.currentSchema = schema;
  if (listSize) {
    schema.addListSize(listSize);
  }
}
SchemaContext.prototype.push = function(name) {
  // console.log(this.names.join() + "," + name);
  this.names.push(name);
  this.parentSchema = this.currentSchema;
  this.currentSchema = this.currentSchema.getChild(name);
}
SchemaContext.prototype.pop = function() {
  this.names.splice(this.names.length - 1, 1);
  this.currentSchema = this.currentSchema.getParent();
  this.getParent = this.currentSchema.getParent();
}

function countListSize(list, schema) {
  if (schema.status === 'OFF') {
    return 0;
  } else if (schema.status === 'FLATTEN') {
    if (list.length > 0) {
      return 1;
    } else {
      return 0;
    }
  }
  var count = 0;
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    if (Array.isArray(obj)) {
      var childSchema = schema.children['[]'];
      count += countListSize(obj, childSchema);
    } else if (typeof obj === 'object') {
      count += countObjectSize(obj, schema);
    } else {
      if (schema.status === 'EXTRACT') {
        count++;
      }
    }
  }
  return count;
}
function countObjectSize(object, schema) {
  if (schema.status === 'OFF') {
    return 1;
  }
  var count = 1;
  for (var key in object) {
    var obj = object[key];
    var childSchema = schema.children[key];
    var tmp = 0;
    if (Array.isArray(obj)) {
      tmp = countListSize(obj, childSchema);
    } else if (typeof obj === 'object') {
      tmp = countObjectSize(obj, childSchema);
    } else {
    }
    if (tmp != 0) {
      if (schema.status === 'ON') {
        count *= tmp;
      } else if (schema.status === 'AS_LIST'){
        count += tmp;
      } else if (schema.status === 'OFF'){
        // OFF - no operation
      } else {
        // console.log(schema.status);
        count *= tmp;
      }
    }
  }
  return count;
}

function createSchema2(obj, context, parentIsList) {
  if (!context) {
    context = new SchemaContext();
  }
  if (!parentIsList) {
    parentIsList = false;
  }
  if (Array.isArray(obj)) {
    context.registerSchema(Type.list, context.currentName(), obj.length);
    obj.forEach(elem => {
      if (Array.isArray(elem)) {
        context.push('[]');
      }
      createSchema2(elem, context, true);
      if (Array.isArray(elem)) {
        context.pop();
      }
    });
  } else if (typeof obj === 'object') {
    if (!parentIsList) {
      context.registerSchema(Type.object, context.currentName());
    }
    for (var key in obj) {
      var elem = obj[key];
      context.push(key);
      createSchema2(elem, context, false);
      context.pop();
    }
  } else {
    context.registerSchema(Type.value, context.currentName());
  }
  return context.rootSchema;
}

function createSchema(list) {
  const ret = [];
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    for(var key in obj) {
      if (ret.indexOf(key) < 0) {
        ret.push(key);
      }
    }
  }
  ret.sort((a, b) => a > b ? -1 : 1);
  console.log(ret);
  return ret;
}

Vue.component('x-row', {
  props: ['h'],
  template: `
<div class="row" :style="{height: heightValue}">
  <slot></slot>
</div>
  `,
  computed: {
    heightValue: function() {
      return `calc(${this.h})`
    }
  }
})

Vue.component('x-panel', {
  props: ['title', 'w', 'h',],
  template: `
<div :style="{position: 'relative', float: 'left', width, height, overflow: 'hidden'}" style="border: 1px solid #777; margin: 1px; border-radius: 5px; padding: 2px;" @mouseover="mouseover">
  <slot></slot>
  <div style="position: absolute; left: calc(100% - 200px); top: 15px; text-align: right; width: 190px;">
    <label style="background-color: blue; opacity: 0.5; padding: 2px 10px; border-radius: 14px; color: white; user-select: none;">{{title}}</label>
  </div>
</div>
  `,
  computed: {
    width: function() {
      return `calc(${this.w} - 8px)`;
    },
    height: function() {
      return `calc(${this.h} - 8px)`
    },
  },
  methods: {
    mouseover: function() {
      this.$emit('mouseover');
    }
  },
})

var schema = {root: null};
Vue.component('x-json', {
  props: ['csvdata', 'w',],
  data: function() {
    return {
      json: null,
      isTextareaFocused: true,
    }
  },
  template:`
<x-panel title="JSON" :w="w" h="100%" v-on:mouseover="mouseover">
  <textarea id="jsonTextarea" placeholder="JSON" :class="['json',]" v-if="showTextArea" v-model="json" @keyup.ctrl.65="ctrlA" @focus="isTextareaFocused = true" @blur="isTextareaFocused = false"></textarea>
  <pre class="json" v-if="!showTextArea" @click="focusJsonTextarea"><code @click="isTextareaFocused = true">{{formattedJson}}</code></pre>
</x-panel>
  `,
  watch: {
    json: function() {
      if (this.csvdata) {
        if (!schema.root) {
          schema.root = createSchema2(this.jsonObject, context);
        }
        console.log(schema.root);
        var count = 0;
        if (Array.isArray(this.jsonObject)) {
          count = countListSize(this.jsonObject, schema.root);
        } else {
          count = countObjectSize(this.jsonObject, schema.root);
        }
        console.log(count);
        schema.count = count;

        this.csvdata.splice(0, this.csvdata.length);

        var list = null;
        if (Array.isArray(this.jsonObject)) {
          list = this.jsonObject;
        } else {
          list = [this.jsonObject];
        }
        var context = new FlattenContext();
        context.setSchema(schema.root);
        // while(extractAll(list, context));
        // Array.prototype.push.apply(this.csvdata, flatten(list));
        // const context2 = new SuperFlattenContext();
        // superflattenList(list, context2);
        // console.log(context2);
        // Array.prototype.push.apply(this.csvdata, context2.root);

        const testSchema = SuperFlatten.createSchema(list);
        console.log(testSchema);

        const value = SuperFlatten.superflatten(list);
        console.log(value);
        Array.prototype.push.apply(this.csvdata, value);
        //
        // if (Array.isArray(this.jsonObject)) {
        //   while(extractAll(this.jsonObject, context));
        //   Array.prototype.push.apply(this.csvdata, flatten(this.jsonObject));
        // } else {
        //   var list = [this.jsonObject];
        //   while(extractAll(list, context));
        //   Array.prototype.push.apply(this.csvdata, flatten(list));
        // }
      }
    }
  },
  computed: {
    showTextArea: function() {
      return this.isTextareaFocused || !this.isValidJson;
    },
    jsonObject: function() {
      try {

        return JSON.parse(this.json);
      } catch (exception) {
        // no operation
      }
    },
    isValidJson: function() {
      if (this.json == null) {
        return false;
      }
      try {
        JSON.parse(this.json);
        return true;
      } catch (exception) {
        console.log(exception);
        return false;
      }
    },
    formattedJson: function() {
      if (!this.isValidJson) {
        return "";
      }
      const TAB = "  ";
      var ret = "";
      var indent = "";
      for (var i = 0; i < this.json.length; i++) {
        var c = this.json[i];
        if (c == '{' || c == '[') {
          indent += TAB;
          ret += c + '\r\n' + indent;
        } else if (c == '}' || c == ']') {
          indent = indent.substring(0, indent.length - 2);
          ret += '\r\n' + indent + c;
        } else if (c == ',') {
          ret += c + '\r\n' + indent;
        } else if (c == '\r' || c == '\n' || c == ' ') {

        } else {
          ret += c;
        }
      }
      return ret.replace(/^[\s\n\r]*/, '');
    },
  },
  methods: {
    ctrlA: function() {
      // console.log('test');
    },
    focusJsonTextarea: function() {
      this.isTextareaFocused = true;
      Vue.nextTick(function() {
        document.getElementById('jsonTextarea').focus();
      })
    },
    mouseover: function() {
      // console.log("JSON");
    }
  }
})
Vue.component('x-csv', {
  props: ['csvdata'],
  template:`
<x-table title="CSV" w="100%" h="100%" :data="csvdata" >
  <a slot="footer" class="btn" style="position: absolute; z-index: 300; top: calc(100% - 80px); left: calc(50% - 100px); width: 150px; opacity: 0.7;" id="download" href="#" download="data.csv" @click="download">DOWNLOAD</a>
</x-table>
  `,
  computed: {
    schema: function() {
      return createSchema(this.csvdata)
    },
    filteredData: function() {
      return this.csvdata.filter((element, index) => index < 8);
    },
  },
  methods: {
    download: function() {
      var bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      var blob = new Blob([bom].concat(this.convertToString(this.csvdata, this.schema)), { "type" : "text/csv" });
      document.getElementById("download").href = window.URL.createObjectURL(blob);
    },
    convertToString: function(list, headers) {
      const ret = [];
      headers.forEach(header => ret.push(header + ','));
      ret.push('\r\n');
      list.forEach(data => {
        headers.forEach(header => {
          var str = data[header];
          if (str === undefined) {
            str = '';
          } else if (typeof str === 'string') {
            str = '"' + str.replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/"/g, '""') + '"';
          }
          ret.push(str + ',')
        });
        ret.push('\r\n');
      });
      return ret;
    }
  }
})
Vue.component('x-config', {
  props: ['schema', 'count', 'w', 'h', 'mouseover'],
  template: `
<x-panel title="Configuration" :w="w" :h="h" :mouseover="mouseover">
  <div style="height: 40px;">
    count: {{count}}
  </div>
  <div style="width: 100%; height: 100%; overflow: scroll; ">
    <x-config-treeview :schema="schema" isroot="true"></x-config-treeview>
  </div>
</x-panel>
  `
})

Vue.component('x-config-treeview', {
  props: ['schema', 'isroot'],
  template: `
  <div :style="{border: 'none', 'margin-left': indent(schema)}">
    <div style="background-color: white; margin: 2px 0 0px 0; box-shadow: 5px 5px 5px rgba(0,0,0,0.4); background-color: azure;">
      <div style="display: inline-block; width: calc(100% - 205px); overflow: hidden; min-width: 100px; height: 20px;" v-if="name">
        <span style="">{{name}}</span>: <span style="font-weight: bold;">{{type}}</span>
      </div>
      <div style="display: inline-block; width: 200px;" v-if="!isroot">
        <div v-if="type == 'object'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'ON'}" @click="schema.status = 'ON'">ON</button><!--
          --><button class="status_button" :class="{active: schema.status == 'AS_LIST'}" @click="schema.status = 'AS_LIST'">AS LIST</button><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="schema.status = 'OFF'">OFF</button>
        </div>
        <div v-if="type == 'list'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'EXTRACT'}" @click="schema.status = 'EXTRACT'">EXTRACT</button><!--
          --><button class="status_button" :class="{active: schema.status == 'FLATTEN'}" @click="schema.status = 'FLATTEN'">FLATTEN</button><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="schema.status = 'OFF'">OFF</button>
        </div>
        <div v-if="type == 'value'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'ON'}" @click="schema.status = 'ON'">ON</button><!--
          --><div style="display: inline-block; width: 66px;"></div><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="schema.status = 'OFF'">OFF</button>
        </div>
      </div>
    </div>
    <x-config-treeview v-for="child in children" :schema="child" :key="child"></x-config-treeview>
  </div>
  `,
  computed: {
    name: function() {
      return this.schema ? this.schema.name : "";
    },
    type: function() {
      return this.schema ? this.schema.type : "";
    },
    children: function() {
      return this.schema ? this.schema.children : [];
    },
  },
  methods: {
    indent: function(elem) {
      if (elem == null) return 0;
      var depth = 0;
      while(elem.parent != null) {
        var elem = elem.parent;
        depth++;
      }
      return (depth * 4) + "px";
    },
  },
  mounted: function() {
    // if (this.schema) {
    //   var defaultValue = '';
    //   switch (this.schema.type) {
    //     case 'object':
    //       defaultValue = 'ON';
    //       break;
    //     case 'list':
    //       defaultValue = 'EXTRACT';
    //       break;
    //     case 'value':
    //       defaultValue = 'ON';
    //       break;
    //     default:
    //       break;
    //   }
    //   Vue.set(this.schema, 'status', defaultValue);
    //   this.schema.status = defaultValue;
    // }
  }
})
Vue.component('x-separator', {
  props: ['offset', 'direction', 'w', 'h', 'top', 'left',],
  data: function() {
    return {
      mouseDownPos: {x: 0, y: 0}
    }
  },
  template: `
  <div :class="{vertical: direction === 'vertical', horizontal : direction === 'horizontal'}" :style="[{ height: heightValue, width: w, position: 'absolute', zIndex: 200, top: topValue, 'left': leftValue,}]" @mousedown="startDrag" ></div>
  `,
  computed: {
    leftValue: function() {
      if (this.direction === 'vertical') {
        return `calc(${this.left})`;
      } else {
        if (this.left) {
          return `calc(${this.left} - ${this.offset.x}px)`;
        } else {
          return '50%';
        }
      }
    },
    topValue: function() {
      if (this.direction === 'horizontal') {
        return `calc(${this.top} - 2px)`;
      } else {
        if (this.top) {
          return `calc(${this.top} - ${this.offset.y}px - 2px)`;
        } else {
          return '50%';
        }
      }
    },
    heightValue: function() {
      return `calc(${this.h})`;
    },
    widthValue: function() {
      return `calc(${this.w})`;
    }
  },
  methods: {
    startDrag: function(e) {
      this.mouseDownPos.x = e.x + this.offset.x;
      this.mouseDownPos.y = e.y + this.offset.y;
    },
    onDrag: function(e) {
      if (this.mouseDownPos.x) {
        this.offset.x = this.mouseDownPos.x - e.x;
        this.offset.y = this.mouseDownPos.y - e.y;
      }
    },
    stopDrag: function(e) {
      this.mouseDownPos.x = null;
      this.mouseDownPos.y = null;
    }
  },
  created: function() {
    document.addEventListener('mousemove', this.onDrag, false);
    document.addEventListener('mouseup', this.stopDrag, false);
  }
})



Vue.component('x-table', {
  props: ['data', 'definitions', 'title', 'w', 'h'],
  data: function() {
    return {
      rowsPerPage: 10,
      rowsPerPageOptions: [5, 10, 25, 50,],
      currentPage: 0,
      filterValue: "",
      footerScrollLeft: 0,
    }
  },
  template: `
  <x-panel :title="title" :w=w :h=h >
    <slot name="header"></slot>
    <div style="margin: 10px 5px; width: calc(100% - 5px); height: calc(100% - 10px); overflow: scroll; position: relative;" @scroll="onscroll">
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px'}">
        <div style="display: inline-block; width: 30%;">
          <div style="width: 100%;">
            <label>Show
              <select v-model="rowsPerPage" class="form-control input-sm">
                <option v-for="val in rowsPerPageOptions" :value="val">{{val}}</option>
              </select>
            entries</label>
          </div>
        </div>
        <div style="display: inline-block; width: 30%; text-align: right;">
          <div style="width: 100%;">
            <label>Search:<input type="search" class="form-control input-sm" v-model="filterValue" ></label>
          </div>
        </div>
      </div>
      <div class="row" style="margin-top: 30px;">
        <div style="width: auto;">
          <table class="datatable">
            <thead>
              <tr role="row">
                <th v-for="prop in properties" >{{prop.key}}</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="d in filteredData" role="row">
                <td v-for="prop in properties" :title="d[prop.key]">{{d[prop.key]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px', 'margin-top': '5px'}">
        <div style="display: inline-block; width: 48%;">
          <div style="width: 100%;">Showing {{showingFrom}} to {{showingTo}} of {{this.data.length}} entries</div>
        </div>
        <div style="display: inline-block; width: 48%;">
          <div style="text-align: right;">
            <ul class="paginate">
              <li :class="['paginate_button', {disabled: currentPage === 0}]" @click="previousPage"><a><label style="user-select: none;">Previous</label></a></li>
              <li v-for="number in pageList" :class="['paginate_button', {active: currentPage + 1 == number}]" @click="currentPage = number - 1"><a><label style="user-select: none;">{{number}}</label></a></li>
              <li :class="['paginate_button', {disabled: !hasNext}]" @click="nextPage"><a><label style="user-select: none;">Next</label></a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <slot name="footer"></slot>
  </x-panel>
  `,
  watch: {
    data: function() {
      this.currentPage = 0;
    },
  },
  computed: {
    properties: function() {
      const properties = [];
      if (!this.definitions) {
        const tmpProperties = [];
        for (var i = 0; i < this.data.length; i++) {
          var obj = this.data[i];
          for (var key in obj) {
            if (tmpProperties.indexOf(key) < 0) {
              tmpProperties.push(key);
            }
          }
        }
        tmpProperties.forEach(prop => properties.push({key: prop}));
      } else {
        this.definitions.forEach(def => {
          for (key in def.properties) {
            properties.push({key});
          }
        })
      }
      properties.sort((prop1, prop2) => prop1.key > prop2.key ? 1 : -1);
      return properties;
    },
    showingFrom: function() {
      return this.currentPage * this.rowsPerPage + 1;
    },
    showingTo: function() {
      if (!this.data) {
        return 0;
      }
      const index = (this.currentPage + 1) * this.rowsPerPage;
      if (this.data.length >= index) {
        return index;
      } else {
        return this.data.length;
      }
    },
    numOfPages: function() {
      if (this.data.length % this.rowsPerPage === 0) {
        return Math.floor(this.data.length / this.rowsPerPage);
      } else {
        return Math.floor(this.data.length / this.rowsPerPage + 1);
      }
    },
    pageList: function() {
      const pageList = [];
      const len = this.numOfPages;
      for (var i = 0; i < len; i++) {
        pageList.push(i + 1);
      }
      return pageList;
    },
    hasNext: function() {
      return this.numOfPages > this.currentPage + 1;
    },
    filteredData: function() {
      var list = [].concat(this.data);
      if (this.filterValue && this.filterValue.length > 0) {
        list = this.filterByString(list, this.filterValue);
      }
      return this.paginate(list);
    },
  },
  methods: {
    onscroll: function(e) {
      this.footerScrollLeft = e.srcElement.scrollLeft;
    },
    previousPage: function() {
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    nextPage: function() {
      if (this.hasNext) {
        this.currentPage = this.currentPage + 1;
      }
    },
    filterByString: function(list, str) {
      return list.filter(elem => JSON.stringify(elem).indexOf(str) >= 0);
    },
    paginate: function(list) {
      var dataFrom = this.currentPage * this.rowsPerPage;
      var dataTo = (this.currentPage + 1) * this.rowsPerPage;
      if (list.length < dataFrom) {
        dataFrom = list.length;
      }
      if (list.length < dataTo) {
        dataTo = list.length;
      }
      return list.slice(dataFrom, dataTo);
    },
  }
})


var app = new Vue({
  el: '#app',
  data: {
    csvdata: [],
    upperMiddleSeparatorOffset: {x: 0, y: 0},
    middleSeparatorOffset: {x: 0, y: 0},
    schema,
  },
  computed: {
    leftPanelWidth: function() {
      return `70% - ${this.upperMiddleSeparatorOffset.x}px`;
    },
    rightPanelWidth: function() {
      return `30% + ${this.upperMiddleSeparatorOffset.x}px`;
    },
    topHight: function() {
      return '50% - 20px';
    }
  },
  methods: {
    // focusJsonPanel: function() {
    //   console.log("sss");
    //   upperMiddleSeparatorOffset.x = 200;
    //   middleSeparatorOffset.y = 100;
    // },
    // focusConfigPanel: function() {
    //   console.log("xxx");
    //   upperMiddleSeparatorOffset.x = -200;
    //   middleSeparatorOffset.y = 100;
    // },
  }
});
</script>

</body>
</html>
