<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
  <script src="https://unpkg.com/vue@2.3.2"></script>
  <style>
  body{
    font-family: "Helvetica Neue", -apple-system,BlinkMacSystemFont,Segoe UI,Hiragino Kaku Gothic ProN,"メイリオ",meiryo,sans-serif;
    /*font-family: "Helvetica Neue", Helvetica, Arial, "游ゴシック体", "Yu Gothic", YuGothic, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif*/
  }
  .header {
    height: 40px;
    background-color: #12486A;
    color: white;
    text-align: center;
  }
  .content{
    height: calc(100% - 40px);
  }
  .column {
    display: block;
    width: 50%;
    float: left;
    height: 100%;
  }
  .row {
    width: 100%;
  }
  textarea.json {
    width: 100%;
    height: 100%;
  }
  pre.json {
    width: calc(100% - 1em);
    height: calc(100% - 1em);
    overflow: scroll;
    padding: 1em 0 0 1em;
    color: #000;
    background-color: #f6f6f6;
    font-family: 'MS Gothic', monospace;
  }
  .btn {
    display: inline-block;
    background-color: #0275d8;
    color: white;
    padding: 10px 25px;
    border-radius: 20px;
    text-align: center;
  }
  .datatable {
	  border-collapse: collapse;
    font-size: 0.8em;
  }
  .datatable th,.datatable td {
  	border: 1px solid rgb(221, 221, 221);
    padding: 5px 10px;
    vertical-align: middle;
    word-break: keep-all;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
  }
  .datatable tr:nth-child(even) {
  	background: #f9f9f9;
  }
  .datatable tr:hover {
  	background: #ff0;
  }
  .paginate {
    letter-spacing: -.4em;
  }
  .paginate li:first-child {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .paginate li:last-child {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
  .paginate > li{
    display: inline-block;
    letter-spacing: normal;
  }
  .paginate_button {
    padding: 8px 12px;
    border: 1px solid rgb(221, 221, 221);
    margin: 0px;
  }
  .paginate_button.active {
    background-color: rgb(221, 221, 221);
  }
  .vertical:hover {
    cursor: n-resize;
  }
  .horizontal:hover {
    cursor: e-resize;
  }
  </style>
</head>
<body>
  <header class="header"><h2 style="font-size: 2em;">JSON to CSV</h2></header>
  <div id="app" class="content">
    <div style="height: 100% position: relative;">
      <x-row :h="'50% - ' + middleSeparatorOffset.y + 'px'">
        <x-json :csvdata="csvdata" :w="leftPanelWidth" ></x-json>
        <x-separator :offset="upperMiddleSeparatorOffset" direction="horizontal" :h="'50% - 18px - ' + middleSeparatorOffset.y + 'px'" w="5px" top="40px" left="70%"></x-separator>
        <x-config :w="rightPanelWidth" h="100%" ></x-config>
      </x-row>
      <x-row :h="'50% + ' + middleSeparatorOffset.y + 'px'">
        <x-separator :offset="middleSeparatorOffset" direction="vertical" h="5px" w="100%" top="50% + 20px" left="0px"></x-separator>
        <x-csv :csvdata="csvdata"></x-csv>
      </x-row>
    </div>
  </div>


<script>

function FlattenContext(names) {
  if (names) {
    this.names = [].concat(names);
  } else {
    this.names = [];
  }
}
FlattenContext.prototype.getNames = function() {
  return this.names;
}
FlattenContext.prototype.push = function(name) {
  this.names.push(name);
}
FlattenContext.prototype.pop = function() {
  this.names.splice(this.names.length - 1, 1);
}
FlattenContext.prototype.currentName = function() {
  var ret = "";
  for (var i = 0; i < this.names.length; i++) {
    var name = this.names[i];
    if (ret.length > 0) {
      ret += ".";
    }
    ret += name;
  }
  return ret;
}

function flatten(obj, context) {
  if (!context) {
    context = new FlattenContext();
  }
  if (Array.isArray(obj) ) {
    const ret = [];
    obj.forEach(elem => {
      ret.push(flatten(elem, context));
    });
    return ret;
  } else if (typeof obj === 'object') {
    var ret = {};
    for (key in obj) {
      const value = obj[key];
      context.push(key);
      Object.assign(ret, flatten(value, context));
      context.pop();
    }
    return ret;
  } else {
    const ret = {};
    ret[context.currentName()] = obj;
    return ret;
  }
}
function extract(obj, name) {
  const ret = [];
  const list = obj[name];
  for (var i = 0; i < list.length; i++) {
    const elem = list[i];
    const retObj = Object.assign({}, obj);
    delete retObj[name];
    ret.push(retObj);
    var thisName = name + "";
    if (typeof elem === 'object') {
      if (Array.isArray(elem) && true) {
        retObj[thisName + ".[]"] = elem;
      } else {
        for (key in elem) {
          retObj[thisName + "." + key] = elem[key];
        }
      }
    } else {
      retObj[thisName] =  elem;
    }
  }
  return ret;
}

function getArrayNameList(obj) {
  const ret = [];
  for (key in obj) {
    if (Array.isArray(obj[key])) {
      ret.push(key);
    }
  }
  return ret;
}

function hasArray(obj) {
  for(var key in obj) {
    var elem = obj[key];
    if (Array.isArray(elem)) {
      return true;
    } else if (typeof elem === 'object') {
      var ret = hasArray(elem);
      if (ret) {
        return true;
      }
    } else {
      // no operation
    }
  }
  return false;
}

function extractAll(list, context) {
  if (!context) {
    context = new FlattenContext();
  }
  var extractedList = [];
  var noExtractList = [];
  var extracted = false;
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    var thisObjExtracted = false;
    if (Array.isArray(obj)) {
      // if "obj" is list, then flatten it.
      // [[1, 2], [3], [4, 5], ...] -> [1, 2, 3, 4, 5, ]
      Array.prototype.push.apply(extractedList, obj);
      extracted = true;
      thisObjExtracted = true;
    } else if (typeof obj === 'object') {
      // if "obj" is object, then loop for all the elements in the object
      for (var key in obj) {
        var elem  = obj[key];
        if (Array.isArray(elem)) {
          // if elem is list, then extract the list
          if (elem.length > 0) {
            Array.prototype.push.apply(extractedList, extract(obj, key));
            extracted = true;
            thisObjExtracted = true;
            break;
          } else {
            delete obj[key];
          }
        } else if (typeof elem === 'object') {
          if (hasArray(elem)) {
            // if the "elem" contains list, then extract
            var extractedCount = 0;
            const childList = [elem];
            context.push(key);
            while(extractAll(childList, context)) {extractedCount++;};
            context.pop();
            if (extractedCount > 0) {
              obj[key] = childList;
              return true;
            }
          }
          continue;
        } else {
          // list of value not need to be extracted
        }
      }
    } else {
      // list of value not need to be extracted
    }
    if (!thisObjExtracted) {
      noExtractList.push(obj);
    }
  }
  if (extracted) {
    list.splice(0, list.length);
    Array.prototype.push.apply(list, extractedList);
    Array.prototype.push.apply(list, noExtractList);
  }
  return extracted;
}
const Type = {
  object: 'object',
  list: 'list',
  value: 'value',
}
const Schema = function(type, name) {
  this.type = type;
  this.name = name;
  this.parent = null;
  this.children = {};
  this.listSize = 0;
}
Schema.prototype.getParent = function() {
  return this.parent;
}
Schema.prototype.setParent = function(parent) {
  this.parent = parent;
}
Schema.prototype.getChild = function(name) {
  return this.children[name];
}
Schema.prototype.addChild = function(schema) {
  if (!this.children[schema.getName()]) {
    this.children[schema.getName()] = schema;
  }
  return this.children[schema.getName()];
}
Schema.prototype.getName = function() {
  return this.name;
}
Schema.prototype.addListSize = function(listSize) {
  this.listSize += listSize;
}

const SchemaContext = function() {
  this.names = ['#root'];
  this.rootSchema = null;
  this.parentSchema = null;
  this.currentSchema = null;
}
// SchemaContext.prototype.registered = function() {
//   return this.currentSchema;
// }
SchemaContext.prototype.currentName = function() {
  return this.names[this.names.length - 1];
}
SchemaContext.prototype.registerSchema = function(type, name, listSize) {
  // console.log(type+ "," + name);
  var schema = new Schema(type, name);
  if (!this.rootSchema) {
    this.rootSchema = schema;
  }
  if (this.parentSchema) {
    schema.setParent(this.parentSchema);
    schema = this.parentSchema.addChild(schema);
  }
  this.currentSchema = schema;
  if (listSize) {
    schema.addListSize(listSize);
  }
}
SchemaContext.prototype.push = function(name) {
  // console.log(this.names.join() + "," + name);
  this.names.push(name);
  this.parentSchema = this.currentSchema;
  this.currentSchema = this.currentSchema.getChild(name);
}
SchemaContext.prototype.pop = function() {
  this.names.splice(this.names.length - 1, 1);
  this.currentSchema = this.currentSchema.getParent();
  this.getParent = this.currentSchema.getParent();
}

function countListSize(list) {
  var count = 0;
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    if (Array.isArray(obj)) {
      count += countListSize(obj);
    } else if (typeof obj === 'object') {
      count += countObjectSize(obj);
    } else {
      count++;
    }
  }
  return count;
}
function countObjectSize(object) {
  var count = 1;
  for (var key in object) {
    var obj = object[key];
    var tmp = 0;
    if (Array.isArray(obj)) {
      tmp = countListSize(obj);
    } else if (typeof obj === 'object') {
      tmp = countObjectSize(obj);
    } else {
    }
    if (tmp != 0) {
      count *= tmp;
    }
  }
  return count;
}

function createSchema2(obj, context, parentIsList) {
  if (!parentIsList) {
    parentIsList = false;
  }
  if (Array.isArray(obj)) {
    context.registerSchema(Type.list, context.currentName(), obj.length);
    obj.forEach(elem => {
      if (Array.isArray(elem)) {
        context.push('[]');
      }
      createSchema2(elem, context, true);
      if (Array.isArray(elem)) {
        context.pop();
      }
    });
  } else if (typeof obj === 'object') {
    if (!parentIsList) {
      context.registerSchema(Type.object, context.currentName());
    }
    for (var key in obj) {
      var elem = obj[key];
      context.push(key);
      createSchema2(elem, context, false);
      context.pop();
    }
  } else {
    context.registerSchema(Type.value, context.currentName());
  }
}

function createSchema(list) {
  const ret = [];
  for (var i = 0; i < list.length; i++) {
    var obj = list[i];
    for(var key in obj) {
      if (ret.indexOf(key) < 0) {
        ret.push(key);
      }
    }
  }
  ret.sort();
  return ret;
}

Vue.component('x-row', {
  props: ['h'],
  template: `
<div class="row" :style="{height: heightValue}">
  <slot></slot>
</div>
  `,
  computed: {
    heightValue: function() {
      return `calc(${this.h})`
    }
  }
})

Vue.component('x-panel', {
  props: ['title', 'w', 'h',],
  template: `
<div :style="{position: 'relative', float: 'left', width, height, overflow: 'hidden'}" style="border: 1px solid #777; margin: 1px; border-radius: 5px; padding: 2px;" @mouseover="mouseover">
  <slot></slot>
  <div style="position: absolute; left: calc(100% - 200px); top: 15px; text-align: right; width: 190px;">
    <label style="background-color: blue; opacity: 0.5; padding: 2px 10px; border-radius: 14px; color: white; user-select: none;">{{title}}</label>
  </div>
</div>
  `,
  computed: {
    width: function() {
      return `calc(${this.w} - 8px)`;
    },
    height: function() {
      return `calc(${this.h} - 8px)`
    },
  },
  methods: {
    mouseover: function() {
      this.$emit('mouseover');
    }
  },
})

Vue.component('x-json', {
  props: ['csvdata', 'w',],
  data: function() {
    return {
      json: null,
      isTextareaFocused: true,
    }
  },
  template:`
<x-panel title="JSON" :w="w" h="100%" v-on:mouseover="mouseover">
  <textarea id="jsonTextarea" placeholder="JSON" :class="['json',]" v-if="showTextArea" v-model="json" @keyup.ctrl.65="ctrlA" @focus="isTextareaFocused = true" @blur="isTextareaFocused = false"></textarea>
  <pre class="json" v-if="!showTextArea" @click="focusJsonTextarea"><code @click="isTextareaFocused = true">{{formattedJson}}</code></pre>
</x-panel>
  `,
  watch: {
    json: function() {
      if (this.csvdata) {
        var context = new SchemaContext();
        // var j = JSON.parse(this.json);
        createSchema2(this.jsonObject, context);
        console.log(context);
        var count = 0;
        if (Array.isArray(this.jsonObject)) {
          count = countListSize(this.jsonObject);
        } else {
          count = countObjectSize(this.jsonObject);
        }
        console.log(count);

        this.csvdata.splice(0, this.csvdata.length);
        if (Array.isArray(this.jsonObject)) {
          while(extractAll(this.jsonObject));
          Array.prototype.push.apply(this.csvdata, flatten(this.jsonObject));
        } else {
          var list = [this.jsonObject];
          while(extractAll(list));
          Array.prototype.push.apply(this.csvdata, flatten(list));
        }
      }
    }
  },
  computed: {
    showTextArea: function() {
      return this.isTextareaFocused || !this.isValidJson;
    },
    jsonObject: function() {
      try {

        return JSON.parse(this.json);
      } catch (exception) {
        // no operation
      }
    },
    isValidJson: function() {
      if (this.json == null) {
        return false;
      }
      try {
        JSON.parse(this.json);
        return true;
      } catch (exception) {
        console.log(exception);
        return false;
      }
    },
    formattedJson: function() {
      if (!this.isValidJson) {
        return "";
      }
      const TAB = "  ";
      var ret = "";
      var indent = "";
      for (var i = 0; i < this.json.length; i++) {
        var c = this.json[i];
        if (c == '{' || c == '[') {
          indent += TAB;
          ret += c + '\r\n' + indent;
        } else if (c == '}' || c == ']') {
          indent = indent.substring(0, indent.length - 2);
          ret += '\r\n' + indent + c;
        } else if (c == ',') {
          ret += c + '\r\n' + indent;
        } else if (c == '\r' || c == '\n' || c == ' ') {

        } else {
          ret += c;
        }
      }
      // console.log(ret);
      return ret.replace(/^[\s\n\r]*/, '');
    },
  },
  methods: {
    ctrlA: function() {
      console.log('test');
    },
    focusJsonTextarea: function() {
      this.isTextareaFocused = true;
      Vue.nextTick(function() {
        document.getElementById('jsonTextarea').focus();
      })
    },
    mouseover: function() {
      console.log("JSON");
    }
  }
})
Vue.component('x-csv', {
  props: ['csvdata'],
  template:`
<x-table title="CSV" w="100%" h="100%" :data="csvdata" >
  <a slot="footer" class="btn" style="position: absolute; z-index: 300; top: calc(100% - 80px); left: calc(50% - 100px); width: 150px; opacity: 0.7;" id="download" href="#" download="data.csv" @click="download">DOWNLOAD</a>
</x-table>
  `,
  computed: {
    schema: function() {
      return createSchema(this.csvdata)
    },
    filteredData: function() {
      return this.csvdata.filter((element, index) => index < 8);
    },
  },
  methods: {
    download: function() {
      var bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      var blob = new Blob([bom].concat(this.convertToString(this.csvdata, this.schema)), { "type" : "text/csv" });
      document.getElementById("download").href = window.URL.createObjectURL(blob);
    },
    convertToString: function(list, headers) {
      const ret = [];
      headers.forEach(header => ret.push(header + ','));
      ret.push('\r\n');
      list.forEach(data => {
        headers.forEach(header => {
          var str = data[header];
          if (str === undefined) {
            str = '';
          } else if (typeof str === 'string') {
            str = '"' + str.replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/"/g, '""') + '"';
          }
          ret.push(str + ',')
        });
        ret.push('\r\n');
      });
      return ret;
    }
  }
})
Vue.component('x-config', {
  props: ['w', 'h', 'mouseover'],
  template: `
<x-panel title="Configuration" :w="w" :h="h" :mouseover="mouseover">
  Configuration will be implemented later..
</x-panel>
  `
})
Vue.component('x-separator', {
  props: ['offset', 'direction', 'w', 'h', 'top', 'left',],
  data: function() {
    return {
      mouseDownPos: {x: 0, y: 0}
    }
  },
  template: `
  <div :class="{vertical: direction === 'vertical', horizontal : direction === 'horizontal'}" :style="[{ height: heightValue, width: w, position: 'absolute', zIndex: 200, top: topValue, 'left': leftValue,}]" @mousedown="startDrag" ></div>
  `,
  computed: {
    leftValue: function() {
      if (this.direction === 'vertical') {
        return `calc(${this.left})`;
      } else {
        if (this.left) {
          return `calc(${this.left} - ${this.offset.x}px)`;
        } else {
          return '50%';
        }
      }
    },
    topValue: function() {
      if (this.direction === 'horizontal') {
        return `calc(${this.top} - 2px)`;
      } else {
        if (this.top) {
          return `calc(${this.top} - ${this.offset.y}px - 2px)`;
        } else {
          return '50%';
        }
      }
    },
    heightValue: function() {
      return `calc(${this.h})`;
    },
    widthValue: function() {
      return `calc(${this.w})`;
    }
  },
  methods: {
    startDrag: function(e) {
      // console.log("startDrag");
      this.mouseDownPos.x = e.x + this.offset.x;
      this.mouseDownPos.y = e.y + this.offset.y;
    },
    onDrag: function(e) {
      if (this.mouseDownPos.x) {
        // console.log("onDrag");
        this.offset.x = this.mouseDownPos.x - e.x;
        this.offset.y = this.mouseDownPos.y - e.y;
      }
    },
    stopDrag: function(e) {
      // console.log("stopDrag");
      this.mouseDownPos.x = null;
      this.mouseDownPos.y = null;
    }
  },
  created: function() {
    document.addEventListener('mousemove', this.onDrag, false);
    document.addEventListener('mouseup', this.stopDrag, false);
  }
})



Vue.component('x-table', {
  props: ['data', 'definitions', 'title', 'w', 'h'],
  data: function() {
    return {
      rowsPerPage: 10,
      rowsPerPageOptions: [5, 10, 25, 50,],
      currentPage: 0,
      filterValue: "",
      footerScrollLeft: 0,
    }
  },
  template: `
  <x-panel :title="title" :w=w :h=h >
    <slot name="header"></slot>
    <div style="margin: 10px 5px; width: calc(100% - 5px); height: calc(100% - 10px); overflow: scroll; position: relative;" @scroll="onscroll">
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px'}">
        <div style="display: inline-block; width: 30%;">
          <div style="width: 100%;">
            <label>Show
              <select v-model="rowsPerPage" class="form-control input-sm">
                <option v-for="val in rowsPerPageOptions" :value="val">{{val}}</option>
              </select>
            entries</label>
          </div>
        </div>
        <div style="display: inline-block; width: 30%; text-align: right;">
          <div style="width: 100%;">
            <label>Search:<input type="search" class="form-control input-sm" v-model="filterValue" ></label>
          </div>
        </div>
      </div>
      <div class="row" style="margin-top: 30px;">
        <div style="width: auto;">
          <table class="datatable">
            <thead>
              <tr role="row">
                <th v-for="prop in properties" >{{prop.key}}</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="d in filteredData" role="row">
                <td v-for="prop in properties" :title="d[prop.key]">{{d[prop.key]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px', 'margin-top': '5px'}">
        <div style="display: inline-block; width: 48%;">
          <div style="width: 100%;">Showing {{showingFrom}} to {{showingTo}} of {{this.data.length}} entries</div>
        </div>
        <div style="display: inline-block; width: 48%;">
          <div style="text-align: right;">
            <ul class="paginate">
              <li :class="['paginate_button', {disabled: currentPage === 0}]" @click="previousPage"><a><label style="user-select: none;">Previous</label></a></li>
              <li v-for="number in pageList" :class="['paginate_button', {active: currentPage + 1 == number}]" @click="currentPage = number - 1"><a><label style="user-select: none;">{{number}}</label></a></li>
              <li :class="['paginate_button', {disabled: !hasNext}]" @click="nextPage"><a><label style="user-select: none;">Next</label></a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <slot name="footer"></slot>
  </x-panel>
  `,
  watch: {
    data: function() {
      this.currentPage = 0;
    },
  },
  computed: {
    properties: function() {
      const properties = [];
      if (!this.definitions) {
        const tmpProperties = [];
        for (var i = 0; i < this.data.length; i++) {
          var obj = this.data[i];
          for (var key in obj) {
            if (tmpProperties.indexOf(key) < 0) {
              tmpProperties.push(key);
            }
          }
        }
        tmpProperties.forEach(prop => properties.push({key: prop}));
        return properties;
      }
      this.definitions.forEach(def => {
        for (key in def.properties) {
          properties.push({key});
        }
      })
      return properties;
    },
    showingFrom: function() {
      return this.currentPage * this.rowsPerPage + 1;
    },
    showingTo: function() {
      if (!this.data) {
        return 0;
      }
      const index = (this.currentPage + 1) * this.rowsPerPage;
      if (this.data.length >= index) {
        return index;
      } else {
        return this.data.length;
      }
    },
    numOfPages: function() {
      if (this.data.length % this.rowsPerPage === 0) {
        return Math.floor(this.data.length / this.rowsPerPage);
      } else {
        return Math.floor(this.data.length / this.rowsPerPage + 1);
      }
    },
    pageList: function() {
      const pageList = [];
      const len = this.numOfPages;
      for (var i = 0; i < len; i++) {
        pageList.push(i + 1);
      }
      return pageList;
    },
    hasNext: function() {
      return this.numOfPages > this.currentPage + 1;
    },
    filteredData: function() {
      var list = [].concat(this.data);
      if (this.filterValue && this.filterValue.length > 0) {
        list = this.filterByString(list, this.filterValue);
      }
      return this.paginate(list);
    },
  },
  methods: {
    onscroll: function(e) {
      this.footerScrollLeft = e.srcElement.scrollLeft;
    },
    previousPage: function() {
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    nextPage: function() {
      if (this.hasNext) {
        this.currentPage = this.currentPage + 1;
      }
    },
    filterByString: function(list, str) {
      return list.filter(elem => JSON.stringify(elem).indexOf(str) >= 0);
    },
    paginate: function(list) {
      var dataFrom = this.currentPage * this.rowsPerPage;
      var dataTo = (this.currentPage + 1) * this.rowsPerPage;
      if (list.length < dataFrom) {
        dataFrom = list.length;
      }
      if (list.length < dataTo) {
        dataTo = list.length;
      }
      return list.slice(dataFrom, dataTo);
    },
  }
})


var app = new Vue({
  el: '#app',
  data: {
    csvdata: [],
    upperMiddleSeparatorOffset: {x: 0, y: 0},
    middleSeparatorOffset: {x: 0, y: 0},
  },
  computed: {
    leftPanelWidth: function() {
      return `70% - ${this.upperMiddleSeparatorOffset.x}px`;
    },
    rightPanelWidth: function() {
      return `30% + ${this.upperMiddleSeparatorOffset.x}px`;
    },
    topHight: function() {
      return '50% - 20px';
    }
  },
  methods: {
    // focusJsonPanel: function() {
    //   console.log("sss");
    //   upperMiddleSeparatorOffset.x = 200;
    //   middleSeparatorOffset.y = 100;
    // },
    // focusConfigPanel: function() {
    //   console.log("xxx");
    //   upperMiddleSeparatorOffset.x = -200;
    //   middleSeparatorOffset.y = 100;
    // },
  }
});
</script>

</body>
</html>
