<html>
<head>
  <meta charset="utf-8">

  <script src="./js/vue.js"></script>
  <script src="./js/vuex.js"></script>
  <script src="./js/superflatten.js"></script>
  <style>

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}

  body{
    font-family: "Helvetica Neue", -apple-system,BlinkMacSystemFont,Segoe UI,Hiragino Kaku Gothic ProN,"メイリオ",meiryo,sans-serif;
    /*font-family: "Helvetica Neue", Helvetica, Arial, "游ゴシック体", "Yu Gothic", YuGothic, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif*/
  }
  .header {
    height: 40px;
    background-color: #12486A;
    color: white;
    text-align: center;
  }
  .content{
    height: calc(100% - 40px);
  }
  .column {
    display: block;
    width: 50%;
    float: left;
    height: 100%;
  }
  .row {
    width: 100%;
  }
  textarea.json {
    width: 100%;
    height: 100%;
  }
  pre.json {
    width: calc(100% - 1em);
    height: calc(100% - 1em);
    overflow: scroll;
    padding: 1em 0 0 1em;
    color: #000;
    background-color: #f6f6f6;
    font-family: 'MS Gothic', monospace;
  }
  .btn {
    display: inline-block;
    background-color: #0275d8;
    color: white;
    padding: 10px 25px;
    border-radius: 20px;
    text-align: center;
  }
  .datatable {
	  border-collapse: collapse;
    font-size: 0.8em;
  }
  .datatable th,.datatable td {
  	border: 1px solid rgb(221, 221, 221);
    padding: 5px 10px;
    vertical-align: middle;
    word-break: keep-all;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
  }
  .datatable tr:nth-child(even) {
  	background: #f9f9f9;
  }
  .datatable tr:hover {
  	background: #ff0;
  }
  .paginate {
    letter-spacing: -.4em;
  }
  .paginate li:first-child {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .paginate li:last-child {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
  .paginate > li{
    display: inline-block;
    letter-spacing: normal;
  }
  .paginate_button {
    padding: 8px 12px;
    border: 1px solid rgb(221, 221, 221);
    margin: 0px;
  }
  .paginate_button.active {
    background-color: rgb(221, 221, 221);
  }
  .vertical:hover {
    cursor: n-resize;
  }
  .horizontal:hover {
    cursor: e-resize;
  }

  .status_button {
    width: 66px;
    margin: 0;
    padding: 1px 0;
    text-align: center;
    user-select: none;
    border: 0;
    font-size: 10px;
    background-color: slategray;
    color: white;
    border-radius: 3px;
  }
  .status_button.active {
    background-color: #01478D;
    color: white;
  }
  </style>
</head>
<body>
  <header class="header"><h2 style="font-size: 2em; font-style: italic">superflatten</h2></header>
  <div id="app" class="content">
    <div style="height: 100% position: relative;">
      <x-row :h="'50% - ' + middleSeparatorOffset.y + 'px'">
        <x-json :w="leftPanelWidth" ></x-json>
        <x-separator :offset="upperMiddleSeparatorOffset" direction="horizontal" :h="'50% - 18px - ' + middleSeparatorOffset.y + 'px'" w="5px" top="40px" left="70%"></x-separator>
        <x-config :w="rightPanelWidth" h="100%" ></x-config>
      </x-row>
      <x-row :h="'50% + ' + middleSeparatorOffset.y + 'px'">
        <x-separator :offset="middleSeparatorOffset" direction="vertical" h="5px" w="100%" top="50% + 20px" left="0px"></x-separator>
        <x-csv></x-csv>
      </x-row>
    </div>
  </div>


<script>

Vue.component('x-row', {
  props: ['h'],
  template: `
<div class="row" :style="{height: heightValue}">
  <slot></slot>
</div>
  `,
  computed: {
    heightValue: function() {
      return `calc(${this.h})`
    }
  }
})

Vue.component('x-panel', {
  props: ['title', 'w', 'h',],
  template: `
<div :style="{position: 'relative', float: 'left', width, height, overflow: 'hidden'}" style="border: 1px solid #777; margin: 1px; border-radius: 5px; padding: 2px;" @mouseover="mouseover">
  <slot></slot>
  <div style="position: absolute; left: calc(100% - 200px); top: 15px; text-align: right; width: 190px;">
    <label style="background-color: blue; opacity: 0.5; padding: 2px 10px; border-radius: 14px; color: white; user-select: none;">{{title}}</label>
  </div>
</div>
  `,
  computed: {
    width: function() {
      return `calc(${this.w} - 8px)`;
    },
    height: function() {
      return `calc(${this.h} - 8px)`
    },
  },
  methods: {
    mouseover: function() {
      this.$emit('mouseover');
    }
  },
})

Vue.component('x-json', {
  props: ['w',],
  data: function() {
    return {
      // json: null,
      isTextareaFocused: true,
    }
  },
  template:`
<x-panel title="JSON" :w="w" h="100%" v-on:mouseover="mouseover">
  <textarea id="jsonTextarea" placeholder="JSON" :class="['json',]" v-if="showTextArea" :value="json" @input="updateJsonStr" @focus="isTextareaFocused = true" @blur="isTextareaFocused = false"></textarea>
  <pre class="json" v-if="!showTextArea" @click="focusJsonTextarea"><code @click="isTextareaFocused = true">{{formattedJson}}</code></pre>
</x-panel>
  `,
  computed: {
    json: function() {
      return this.$store.state.jsonStr;
    },
    jsonObject: function() {
      return this.$store.getters.jsonObject;
    },
    isValidJson: function() {
      return this.$store.getters.isValidJson;
    },
    showTextArea: function() {
      return this.isTextareaFocused || !this.isValidJson;
    },
    formattedJson: function() {
      if (!this.isValidJson) {
        return "";
      }
      const TAB = "  ";
      var ret = "";
      var indent = "";
      for (var i = 0; i < this.json.length; i++) {
        var c = this.json[i];
        if (c == '{' || c == '[') {
          indent += TAB;
          ret += c + '\r\n' + indent;
        } else if (c == '}' || c == ']') {
          indent = indent.substring(0, indent.length - 2);
          ret += '\r\n' + indent + c;
        } else if (c == ',') {
          ret += c + '\r\n' + indent;
        } else if (c == '\r' || c == '\n' || c == ' ') {

        } else {
          ret += c;
        }
      }
      return ret.replace(/^[\s\n\r]*/, '');
    },
  },
  methods: {
    updateJsonStr: function(e) {
      this.$store.commit('updateJsonStr', e.target.value);
    },
    focusJsonTextarea: function() {
      this.isTextareaFocused = true;
      Vue.nextTick(function() {
        document.getElementById('jsonTextarea').focus();
      })
    },
    mouseover: function() {
      // console.log("JSON");
    }
  }
})
Vue.component('x-csv', {
  template:`
<x-table title="CSV" w="100%" h="100%" :data='csvdata'>
  <a slot="footer" class="btn" style="position: absolute; z-index: 300; top: calc(100% - 80px); left: calc(50% - 100px); width: 150px; opacity: 0.7;" id="download" href="#" download="data.csv" @click="download">DOWNLOAD</a>
</x-table>
  `,
  computed: {
    csvdata: function() {
      return this.$store.getters.csvdata;
    },
    filteredData: function() {
      return this.csvdata.filter((element, index) => index < 8);
    },
    schema: function() {
      return this.createTableHeader(this.csvdata)
    },
  },
  methods: {
    download: function() {
      var bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      var blob = new Blob([bom].concat(this.convertToString(this.csvdata, this.schema)), { "type" : "text/csv" });
      document.getElementById("download").href = window.URL.createObjectURL(blob);
    },
    convertToString: function(list, headers) {
      const ret = [];
      headers.forEach(header => ret.push(header + ','));
      ret.push('\r\n');
      list.forEach(data => {
        headers.forEach(header => {
          var str = data[header];
          if (str === undefined) {
            str = '';
          } else if (typeof str === 'string') {
            str = '"' + str.replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/"/g, '""') + '"';
          }
          ret.push(str + ',')
        });
        ret.push('\r\n');
      });
      return ret;
    },
    createTableHeader: function(list) {
      const ret = [];
      for (var i = 0; i < list.length; i++) {
        var obj = list[i];
        for(var key in obj) {
          if (ret.indexOf(key) < 0) {
            ret.push(key);
          }
        }
      }
      ret.sort((a, b) => a > b ? -1 : 1);
      return ret;
    }
  }
})
Vue.component('x-config', {
  props: ['w', 'h',],
  template: `
<x-panel title="Configuration" :w="w" :h="h">
  <div style="height: 40px;">
    count: {{count}}
  </div>
  <div style="width: 100%; height: calc(100% - 40px); overflow: scroll; ">
    <x-config-treeview :schema="schema" isroot="true"></x-config-treeview>
  </div>
</x-panel>
  `,
  computed: {
    schema: function() {
      return this.$store.state.jsonSchema;
    },
    count: function() {
      return this.$store.getters.csvdataCount;
    },
  }
})

Vue.component('x-config-treeview', {
  props: ['schema', 'isroot'],
  template: `
  <div :style="{border: 'none', 'margin-left': indent(schema)}">
    <div style="background-color: white; margin: 2px 0 0px 0; box-shadow: 5px 5px 5px rgba(0,0,0,0.4); background-color: azure;">
      <div style="display: inline-block; width: calc(100% - 205px); overflow: hidden; min-width: 100px; height: 20px;" v-if="name">
        <span style="">{{name}}</span>: <span style="font-weight: bold;">{{type}}</span>
      </div>
      <div style="display: inline-block; width: 200px;">
        <div v-if="type == 'object'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'ON'}" @click="updateSchemaStatus(schema, 'ON')">ON</button><!--
          --><button class="status_button" :class="{active: schema.status == 'AS_LIST'}" @click="updateSchemaStatus(schema, 'AS_LIST')">AS LIST</button><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="updateSchemaStatus(schema, 'OFF')">OFF</button>
        </div>
        <div v-if="type == 'list'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'ON'}" @click="updateSchemaStatus(schema, 'ON')">ON</button><!--
          --><button class="status_button" :class="{active: schema.status == 'AS_OBJECT'}" @click="updateSchemaStatus(schema, 'AS_OBJECT')">AS OBJECT</button><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="updateSchemaStatus(schema, 'OFF')">OFF</button>
        </div>
        <div v-if="type == 'value'" style="padding-bottom: 2px;">
          <button class="status_button" :class="{active: schema.status == 'ON'}" @click="updateSchemaStatus(schema, 'ON')">ON</button><!--
          --><div style="display: inline-block; width: 66px;"></div><!--
          --><button class="status_button" :class="{active: schema.status == 'OFF'}" @click="updateSchemaStatus(schema, 'OFF')">OFF</button>
        </div>
      </div>
    </div>
    <x-config-treeview v-for="child in children" :schema="child" :key="child"></x-config-treeview>
  </div>
  `,
  computed: {
    name: function() {
      return this.schema ? this.schema.name : "";
    },
    type: function() {
      return this.schema ? this.schema.type : "";
    },
    children: function() {
      return this.schema ? this.schema.children : [];
    },
  },
  methods: {
    indent: function(elem) {
      if (elem == null) return 0;
      var depth = 0;
      while(elem.parent != null) {
        var elem = elem.parent;
        depth++;
      }
      return (depth * 4) + "px";
    },
    updateSchemaStatus: function(schema, status) {
      this.$store.commit('updateSchemaStatus', {schema, status});
    }
  },
  mounted: function() {
  }
})
Vue.component('x-separator', {
  props: ['offset', 'direction', 'w', 'h', 'top', 'left',],
  data: function() {
    return {
      mouseDownPos: {x: 0, y: 0}
    }
  },
  template: `
  <div :class="{vertical: direction === 'vertical', horizontal : direction === 'horizontal'}" :style="[{ height: heightValue, width: w, position: 'absolute', zIndex: 200, top: topValue, 'left': leftValue,}]" @mousedown="startDrag" ></div>
  `,
  computed: {
    leftValue: function() {
      if (this.direction === 'vertical') {
        return `calc(${this.left})`;
      } else {
        if (this.left) {
          return `calc(${this.left} - ${this.offset.x}px)`;
        } else {
          return '50%';
        }
      }
    },
    topValue: function() {
      if (this.direction === 'horizontal') {
        return `calc(${this.top} - 2px)`;
      } else {
        if (this.top) {
          return `calc(${this.top} - ${this.offset.y}px - 2px)`;
        } else {
          return '50%';
        }
      }
    },
    heightValue: function() {
      return `calc(${this.h})`;
    },
    widthValue: function() {
      return `calc(${this.w})`;
    }
  },
  methods: {
    startDrag: function(e) {
      this.mouseDownPos.x = e.x + this.offset.x;
      this.mouseDownPos.y = e.y + this.offset.y;
    },
    onDrag: function(e) {
      if (this.mouseDownPos.x) {
        this.offset.x = this.mouseDownPos.x - e.x;
        this.offset.y = this.mouseDownPos.y - e.y;
      }
    },
    stopDrag: function(e) {
      this.mouseDownPos.x = null;
      this.mouseDownPos.y = null;
    }
  },
  created: function() {
    document.addEventListener('mousemove', this.onDrag, false);
    document.addEventListener('mouseup', this.stopDrag, false);
  }
})



Vue.component('x-table', {
  props: ['data', 'definitions', 'title', 'w', 'h'],
  data: function() {
    return {
      rowsPerPage: 10,
      rowsPerPageOptions: [5, 10, 25, 50,],
      currentPage: 0,
      filterValue: "",
      footerScrollLeft: 0,
    }
  },
  template: `
  <x-panel :title="title" :w=w :h=h >
    <slot name="header"></slot>
    <div style="margin: 10px 5px; width: calc(100% - 5px); height: calc(100% - 10px); overflow: scroll; position: relative;" @scroll="onscroll">
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px'}">
        <div style="display: inline-block; width: 30%;">
          <div style="width: 100%;">
            <label>Show
              <select v-model="rowsPerPage" class="form-control input-sm">
                <option v-for="val in rowsPerPageOptions" :value="val">{{val}}</option>
              </select>
            entries</label>
          </div>
        </div>
        <div style="display: inline-block; width: 30%; text-align: right;">
          <div style="width: 100%;">
            <label>Search:<input type="search" class="form-control input-sm" v-model="filterValue" ></label>
          </div>
        </div>
      </div>
      <div class="row" style="margin-top: 30px;">
        <div style="width: auto;">
          <table class="datatable">
            <thead>
              <tr role="row">
                <th v-for="prop in properties" >{{prop.key}}</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="d in filteredData" role="row">
                <td v-for="prop in properties" :title="d[prop.key]">{{d[prop.key]}}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="row" :style="{position: 'absolute', left: footerScrollLeft + 'px', 'margin-top': '5px'}">
        <div style="display: inline-block; width: 48%;">
          <div style="width: 100%;">Showing {{showingFrom}} to {{showingTo}} of {{this.data.length}} entries</div>
        </div>
        <div style="display: inline-block; width: 48%;">
          <div style="text-align: right;">
            <ul class="paginate">
              <li :class="['paginate_button', {disabled: currentPage === 0}]" @click="previousPage"><a><label style="user-select: none;">Previous</label></a></li>
              <li v-for="number in pageList" :class="['paginate_button', {active: currentPage + 1 == number}]" @click="currentPage = number - 1"><a><label style="user-select: none;">{{number}}</label></a></li>
              <li :class="['paginate_button', {disabled: !hasNext}]" @click="nextPage"><a><label style="user-select: none;">Next</label></a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <slot name="footer"></slot>
  </x-panel>
  `,
  watch: {
    data: function() {
      this.currentPage = 0;
    },
  },
  computed: {
    properties: function() {
      const properties = [];
      if (!this.definitions) {
        const tmpProperties = [];
        for (var i = 0; i < this.data.length; i++) {
          var obj = this.data[i];
          for (var key in obj) {
            if (tmpProperties.indexOf(key) < 0) {
              tmpProperties.push(key);
            }
          }
        }
        tmpProperties.forEach(prop => properties.push({key: prop}));
      } else {
        this.definitions.forEach(def => {
          for (key in def.properties) {
            properties.push({key});
          }
        })
      }
      properties.sort((prop1, prop2) => prop1.key > prop2.key ? 1 : -1);
      return properties;
    },
    showingFrom: function() {
      return this.currentPage * this.rowsPerPage + 1;
    },
    showingTo: function() {
      if (!this.data) {
        return 0;
      }
      const index = (this.currentPage + 1) * this.rowsPerPage;
      if (this.data.length >= index) {
        return index;
      } else {
        return this.data.length;
      }
    },
    numOfPages: function() {
      if (this.data.length % this.rowsPerPage === 0) {
        return Math.floor(this.data.length / this.rowsPerPage);
      } else {
        return Math.floor(this.data.length / this.rowsPerPage + 1);
      }
    },
    pageList: function() {
      const pageList = [];
      const len = this.numOfPages;
      for (var i = 0; i < len; i++) {
        pageList.push(i + 1);
      }
      return pageList;
    },
    hasNext: function() {
      return this.numOfPages > this.currentPage + 1;
    },
    filteredData: function() {
      var list = [].concat(this.data);
      if (this.filterValue && this.filterValue.length > 0) {
        list = this.filterByString(list, this.filterValue);
      }
      return this.paginate(list);
    },
  },
  methods: {
    onscroll: function(e) {
      this.footerScrollLeft = e.srcElement.scrollLeft;
    },
    previousPage: function() {
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    nextPage: function() {
      if (this.hasNext) {
        this.currentPage = this.currentPage + 1;
      }
    },
    filterByString: function(list, str) {
      return list.filter(elem => JSON.stringify(elem).indexOf(str) >= 0);
    },
    paginate: function(list) {
      var dataFrom = this.currentPage * this.rowsPerPage;
      var dataTo = (this.currentPage + 1) * this.rowsPerPage;
      if (list.length < dataFrom) {
        dataFrom = list.length;
      }
      if (list.length < dataTo) {
        dataTo = list.length;
      }
      return list.slice(dataFrom, dataTo);
    },
  }
})

const store = new Vuex.Store(
  {
    strict: true,
    state:{
      jsonStr: '',
      jsonSchema: null,
    },
    mutations: {
      updateJsonStr: (state, jsonStr) => {
        state.jsonStr = jsonStr;
        const currentSchema = state.jsonSchema;
        state.jsonSchema = SuperFlatten.createSchema(store.getters.jsonObject);
        const copySchema = (fromSchema, toSchema) => {
          if (!fromSchema || !toSchema) {
            return;
          }
          toSchema.status = fromSchema.status;
          for (key in fromSchema.getChildren()) {
            const fromChild = fromSchema.getChild(key);
            const toChild = toSchema.getChild(key);
            copySchema(fromChild, toChild);
          }
        }
        copySchema(currentSchema, state.jsonSchema);
      },
      updateSchemaStatus: (state, args) => {
        args.schema.status = args.status;
      },
    },
    getters: {
      jsonObject: (state) => {
        let jsonObject = null;
        try {
          jsonObject = JSON.parse(state.jsonStr);
        } catch (exception) {
          jsonObject = null;
        }
        return jsonObject;
      },
      renderable: (state) => {
        return store.getters.csvdataCount < 10000;
      },
      csvdata: (state) => {
        const jsonObject = store.getters.jsonObject;
        if (!store.getters.renderable) {
          return [];
        }
        return SuperFlatten.superflatten(jsonObject, state.jsonSchema);
      },
      csvdataCount: (state) => {
        return SuperFlatten.countSize(store.getters.jsonObject, state.jsonSchema);
      },
      isValidJson: (state) => {
        try {
          JSON.parse(state.jsonStr);
          return true;
        } catch (exception) {
          return false;
        }
      },
    },
  }
)

var app = new Vue({
  el: '#app',
  store,
  data: {
    upperMiddleSeparatorOffset: {x: 0, y: 0},
    middleSeparatorOffset: {x: 0, y: 0},
  },
  computed: {
    leftPanelWidth: function() {
      return `70% - ${this.upperMiddleSeparatorOffset.x}px`;
    },
    rightPanelWidth: function() {
      return `30% + ${this.upperMiddleSeparatorOffset.x}px`;
    },
    topHight: function() {
      return '50% - 20px';
    }
  },
  methods: {
  }
});
</script>

</body>
</html>
